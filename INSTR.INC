LINE,       {debug line info  line_number(w)* =>}
QUIT,       {ends execution   => ; throw exception 'quit'}
ENTRY,      {entry to proc    => ; save and set new frame}
LOCINI,     {init locals      size(i) => data(size*4) ; size<>0 !}
RET,        {return from proc params_size(i) => ; restore stack, restore frame, pop parameters and return}
CALL,       {call procedure   addr(i) => next_addr ; set new addr}
SYS,        {call system proc addr(i) => next_addr ; set new addr}
JMP,        {jump relative    offset(w)* =>}
JNZ,        {jump if not zero op(i),offset(w)* =>}
JZ,         {jump if zero     op(i),offset(w)* =>}
CIE,        {cmp int equal    op1(i),op2(i) => res(i)}
CINE,       {cmp int noneq    op1(i),op2(i) => res(i)}
CIL,        {cmp int less     op1(i),op2(i) => res(i)}
CILE,       {cmp int ls or eq op1(i),op2(i) => res(i)}
CIG,        {cmp int greater  op1(i),op2(i) => res(i)}
CIGE,       {cmp int gr or eq op1(i),op2(i) => res(i)}
CFE,        {cmp fl equal     op1(f),op2(f) => res(i)}
CFNE,       {cmp fl noneq     op1(f),op2(f) => res(i)}
CFL,        {cmp fl less      op1(f),op2(f) => res(i)}
CFLE,       {cmp fl ls or eq  op1(f),op2(f) => res(i)}
CFG,        {cmp fl greater   op1(f),op2(f) => res(i)}
CFGE,       {cmp fl gr or eq  op1(f),op2(f) => res(i)}
ARRACC,     {array acces      index(i), array_info(i)* => offset(i)}
MKGLB,      {make global      loc.addr(i) => glob.addr(i)}
CNVF,       {convert to float value(i) => value(f)}
PUSHZ,      {push zero        => 0(i)}
PUSHO,      {push one         => 1(i)}
PUSH1,      {push byte        value(b)* => value(i)}
PUSH2,      {push word        value(w)* => value(i)}
STORI,      {store integer    addr(i),value(i) => }
STORF,      {store float      addr(i),value(f) => }
STORM,      {store memory     addr(i),value(length*4),length(i) => }
LOADI,      {load integer     addr(i) => value(i)}
LOADF,      {load float       addr(i) => value(f)}
LOADM,      {load memory      addr(i), length(i) => value(length*4)}
PUSHI,      {push integer     value(i)* => value(i)}
PUSHF,      {push float       value(f)* => value(f)}
ADDI,       {addition int     op1(i),op2(i) => op1+op2(i)}
ADDF,       {addition float   op1(f),op2(f) => op1+op2(f)}
SUBI,       {subtract int     op1(i),op2(i) => op1-op2(i)}
SUBF,       {subtract float   op1(f),op2(f) => op1-op2(f)}
MULI,       {multipl. int     op1(i),op2(i) => op1*op2(i)}
MULF,       {multipl. float   op1(f),op2(f) => op1*op2(f)}
DIVI,       {division int     op1(i),op2(i) => op1/op2(i)}
DIVF,       {division float   op1(f),op2(f) => op1/op2(f)}
NEGI,       {negation int     op(i) => -op(i)}
NEGF,       {negation float   op(f) => -op(f)}
MODI,       {div modulo int   op1(i),op2(i) => (op1 mod op2)(i)}
ORI,        {or integer       op1(i),op2(i) => (op1 or op2)(i)}
XORI,       {xor integer      op1(i),op2(i) => (op1 xor op2)(i)}
ANDI,       {and integer      op1(i),op2(i) => (op1 and op2)(i)}
PUSHGZ,     {push 0 to gl adr => 0(i)}
PUSHGO,     {push 1 to gl adr => 1(i)}
PUSHG1,     {push b to gl adr value(b)* => value(i)}
PUSHG2,     {push w to gl adr value(w)* => value(i)}
PUSHGI,     {push i to gl adr value(i)* => value(i)}

